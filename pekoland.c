#include <gb/gb.h>
#include <stdio.h>
#include <time.h>
#include <gb/drawing.h>
//#include "tiles_bg.c"
//#include "map.c"

#define TILES_WIDTH 30
#define TILES_HEIGHT 18
#define LEVEL_WIDTH (TILES_WIDTH * 8)
#define LEVEL_HEIGHT (TILES_HEIGHT * 8)

#define SPRITES_MODE 2 //8X8 = 1. 8X16 = 2
#define PRECISION_BITS 8
#define INC_BITS <<PRECISION_BITS
#define DEC_BITS >>PRECISION_BITS

#define TRUE 1
#define FALSE 0

#define PLAYER_HEIGHT 16
#define PLAYER_WIDTH 8

//#define DEC_BITS(x) ((x) >> PRECISION_BITS)

//Posicion de los tiles
#define TILE_0 0
#define TILE_1 (TILE_0 + SPRITES_MODE)
#define TILE_2 (TILE_1 + SPRITES_MODE)
#define TILE_3 (TILE_2 + SPRITES_MODE)
#define TILE_4 (TILE_3 + SPRITES_MODE)
#define TILE_5 (TILE_4 + SPRITES_MODE)
#define TILE_6 (TILE_5 + SPRITES_MODE)
#define TILE_7 (TILE_6 + SPRITES_MODE)
#define TILE_8 (TILE_7 + SPRITES_MODE)
#define TILE_9 (TILE_8 + SPRITES_MODE)
#define TILE_PLAYER_IDLE_F1 20
#define TILE_PLAYER_IDLE_F2 22
#define TILE_PLAYER_RUN_F1 24
#define TILE_PLAYER_RUN_F2 26
#define TILE_PLAYER_RUN_F3 28
#define TILE_PLAYER_JUMP_UP 30
#define TILE_PLAYER_JUMP_DOWN 32
#define TOTAL_TILES 34 //Total + 2

//Sprites (Maximo 39)
#define SPRITE_DIGIT_1 0
#define SPRITE_DIGIT_2 SPRITE_DIGIT_1 + 1
#define SPRITE_DIGIT_3 SPRITE_DIGIT_2 + 1
#define SPRITE_DIGIT_4 SPRITE_DIGIT_3 + 1
#define SPRITE_DIGIT_5 SPRITE_DIGIT_4 + 1
//Player animations
#define SPRITE_PLAYER SPRITE_DIGIT_5 + 1

#define SCREEN_WIDTH 160
#define SCREEN_HEIGHT 144
#define SCREEN_WIDTH2 (SCREEN_WIDTH >> 1)
#define SCREEN_HEIGHT2 (SCREEN_HEIGHT >> 1)
#define SCREEN_WIDTH4 (SCREEN_WIDTH >> 2)
#define SCREEN_HEIGHT4 (SCREEN_HEIGHT >> 2)
#define SCREEN_WIDTH8 (SCREEN_WIDTH >> 3)
#define SCREEN_HEIGHT8 (SCREEN_HEIGHT >> 3)

//Player states
#define STATE_IDLE 0
#define STATE_RUN 1
#define STATE_JUMP 2



UBYTE keyPressUP(UBYTE key) {
    if( key & (J_UP)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressDOWN(UBYTE key) {
    if( key & (J_DOWN)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressLEFT(UBYTE key) {
    if( key & (J_LEFT)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressRIGHT(UBYTE key) {
    if( key & (J_RIGHT)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressA(UBYTE key) {
    if( key & (J_A)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressB(UBYTE key) {
    if( key & (J_B)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressSTART(UBYTE key) {
    if( key & (J_START)) {
        return 1;
    } else {
        return 0;
    }
}
UBYTE keyPressSELECT(UBYTE key) {

    if( key & (J_SELECT)) {
        return 1;
    } else {
        return 0;
    }
}

//Level map
const unsigned char TILE_LEVEL_MAP[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,
  0x00,0x00,0x02,0x00,0x00,0x02,0x02,0x00,0x00,0x02,
  0x00,0x00,0x02,0x02,0x02,0x02,0x00,0x00,0x02,0x00,
  0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x01,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x00,0x00,0x01,0x00,0x01,0x01,0x01,0x01,
  0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,
  0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
  0x01,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x02,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x01,0x01,0x00,0x00,0x01,0x01,0x00,0x00,0x00,
  0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x02,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,
  0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x02,0x02,0x00,0x02,0x02,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x02,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x02,0x02,0x00,0x02,0x02,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
};
//Tiles level 8x8
const unsigned char TILE_LEVEL_DATA[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0xBD,0xC3,
  0xBD,0xC3,0xBD,0xC3,0x81,0xFF,0xFF,0xFF,
  0xFF,0xFF,0xFF,0x81,0xDB,0xA5,0xDB,0xA5,
  0xDB,0xA5,0xDB,0xA5,0xFF,0x81,0xFF,0xFF,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0x81,0xFF,
  0x81,0xFF,0xBD,0xC3,0x81,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

//Tiles sprites 8x16
const unsigned char TILES_DATA[] =
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0xA5,0xDB,
  0xA5,0xDB,0xBD,0xC3,0x81,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0x8D,0xF3,0xBD,0xC3,
  0x8D,0xF3,0x8D,0xF3,0x81,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0x8D,0xF3,
  0xB1,0xCF,0xBD,0xC3,0x81,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0x8D,0xF3,
  0x9D,0xE3,0x8D,0xF3,0xBD,0xC3,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xAD,0xD3,0xBD,0xC3,
  0x8D,0xF3,0x8D,0xF3,0x81,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0xB1,0xCF,
  0xBD,0xC3,0x8D,0xF3,0xBD,0xC3,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0xB1,0xCF,
  0xBD,0xC3,0xB5,0xCB,0xBD,0xC3,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0x8D,0xF3,
  0x99,0xE7,0x99,0xE7,0x81,0xFF,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0xAD,0xD3,
  0xBD,0xC3,0xAD,0xD3,0xBD,0xC3,0xFF,0xFF,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xFF,0xFF,0x81,0xFF,0xBD,0xC3,0xAD,0xD3,
  0xBD,0xC3,0x8D,0xF3,0x8D,0xF3,0xFF,0xFF,
  0x7E,0x7E,0xFF,0xE0,0xF7,0xFE,0xF7,0xFA,
  0xD1,0xFE,0xDF,0xF0,0xDD,0xE3,0x7F,0x40,
  0x81,0xFF,0xC9,0xF7,0xC9,0xF7,0xCB,0x34,
  0xC3,0x3C,0x00,0x66,0xE7,0xE7,0xE7,0xE7,
  0x00,0x00,0x7E,0x7E,0xFF,0xE0,0xF7,0xFE,
  0xF7,0xFA,0xD1,0xFE,0xDF,0xF0,0xDD,0xE3,
  0x7F,0x40,0x81,0xFF,0xC9,0xF7,0xC9,0xF7,
  0xCB,0x34,0xC3,0x3C,0xE7,0xE7,0xE7,0xE7,
  0x7E,0x7E,0xFF,0xE0,0xF7,0xFE,0xF7,0xFA,
  0xD1,0xFE,0xDF,0xF0,0xDD,0xE3,0x7F,0x40,
  0x81,0xFF,0xC9,0xF7,0xC9,0xF7,0xCB,0x34,
  0xC3,0x3C,0x00,0x66,0x77,0x77,0x77,0x77,
  0x7E,0x7E,0xFF,0xE0,0xF7,0xFE,0xF7,0xFA,
  0xD1,0xFE,0xDF,0xF0,0xDD,0xE3,0x7F,0x40,
  0x81,0xFF,0xC9,0xF7,0xC9,0xF7,0xCB,0x34,
  0xC3,0x3C,0x00,0x36,0x3F,0x3F,0x3F,0x3F,
  0x7E,0x7E,0xFF,0xE0,0xF7,0xFE,0xF7,0xFA,
  0xD1,0xFE,0xDF,0xF0,0xDD,0xE3,0x7F,0x40,
  0x81,0xFF,0xC9,0xF7,0xC9,0xF7,0xCB,0x34,
  0xC3,0x3C,0x00,0x3C,0x3E,0x3E,0x3E,0x3E,
  0x00,0x00,0x7E,0x7E,0xFF,0xE0,0xF7,0xFE,
  0xF7,0xFA,0xD1,0xFE,0xDF,0xF0,0xDD,0xE3,
  0x7F,0x40,0x80,0xFE,0xC8,0xF6,0xC8,0xF6,
  0xC8,0x36,0xD9,0x3F,0x3B,0x1F,0x1B,0x1B,
  0x00,0x00,0x00,0x00,0x7E,0x7E,0xFF,0xE0,
  0xF7,0xFE,0xF7,0xFA,0xD1,0xFE,0xDF,0xF0,
  0xDD,0xE3,0x7F,0x40,0x80,0xFE,0xC8,0xF6,
  0xC8,0xF6,0xF1,0x3F,0xF3,0x3F,0x33,0x33
};

UINT8 getNumberDigits(UINT16 number, UINT8 c);
UINT8 getDigit(UINT16 number, UINT8 digit);
void drawPoints(UINT16 points, UINT8 digits, UINT8 positionX, UINT8 positionY);
void drawNumbers(UINT8 digits, UINT16 number, UINT8 positionX, UINT8 positionY);

UINT8 getNumberDigits(UINT16 number, UINT8 c) {
    c++;
    if(number / 10 == 0) {
        return c;
    } else {
        number /= 10;
        return getNumberDigits(number, c);
    }
}

UINT8 getDigit(UINT16 number, UINT8 digit) {

    if(digit >= getNumberDigits(number, 0)) {
        return 0;
    } else {
        int d = number%10;
        if(digit == 0) {
            return d;
        } else {
            int n = number/10;
            digit--;
            getDigit(n, digit);
        }
    }
}

void drawPoints(UINT16 points, UINT8 digits, UINT8 positionX, UINT8 positionY) {

    UINT8 i;
    UINT8 digit;
    for(i = 0; i < digits; i++) {
        //UINT8 tile = points[i] - 48;//Cast chat to int
        digit = getDigit(points, (digits - (i+1)));
        set_sprite_tile(i, digit * SPRITES_MODE);
        move_sprite(i, positionX + (i * 8), positionY);
    }
}

void drawNumbers(UINT8 digits, UINT16 number, UINT8 positionX, UINT8 positionY) {

    UINT8 digit = (number % 10);

    set_sprite_tile(digits-1, digit * SPRITES_MODE);
    move_sprite(digits-1, positionX + ((digits-1) * 8), positionY);

    if(number / 10 == 0) {
        return;
    } else {
        digits--;
        drawNumbers(digits, number / 10, positionX, positionY);
    }
}

struct Player {
    UINT16 x;
    UINT16 y;
    UINT16 newX;
    UINT16 newY;
    UINT16 speed;
    UINT16 velocityDesc;
    UINT16 velocityAsc;
    UBYTE state;
    UBYTE frame;
};

struct Camera {
    UINT16 x;
    UINT16 y;
};

UINT16 getCameraX(UINT16 objX) {

    if(objX > SCREEN_WIDTH2){
        if(objX < LEVEL_WIDTH - SCREEN_WIDTH2){
            return objX - SCREEN_WIDTH2;
        }else{
            return LEVEL_WIDTH - SCREEN_WIDTH;
        }
    }else{
        return 0;
    }
}

UBYTE getFrameIdle(UBYTE gameFrame, UBYTE playerFrame) {
    if(gameFrame%30 == 0) {
        playerFrame += SPRITES_MODE;
        if(playerFrame > TILE_PLAYER_IDLE_F2){
            playerFrame = TILE_PLAYER_IDLE_F1;
        }
    }
    return playerFrame;
}

UBYTE getFrameRun(UBYTE gameFrame, UBYTE playerFrame) {
    if(gameFrame%4 == 0) {
        playerFrame += SPRITES_MODE;
        if(playerFrame > TILE_PLAYER_RUN_F3){
            playerFrame = TILE_PLAYER_RUN_F1;
        }
    }
    return playerFrame;
}

UBYTE checkTileColision(UINT16 spriteX, UINT16 spriteY, UINT16 tileX, UINT16 tileY){//Anchor -> x1:abajo derecha, x1:arriba izquierda
    if(spriteX > tileX && spriteX - 8 < tileX  + 8 && spriteY > tileY && spriteY -16 < tileY +8){
        return 1;
    }
    return 0;
}

UINT16 getGravitySpeed(UINT16 gravityForce, UINT16 weight){
    return gravityForce * weight;
}

UINT16 isCollisonDown(UINT16 x, UINT16 y, UINT16 w, UINT16 h) {
    UINT16 indX;
    UINT16 indY;
    UINT16 indXY;
    UINT16 offsetX;
    UINT8 i;

    //Si el personaje mide mas de un tile en ancho, se va recorriendo toda su anchura (de 8 en 8) y comprobando si colisiona
    for(i = 0; i < w/8; i++){
        offsetX = i * 8;
        //Convierte la posicion del player en index x/y
        indX = (x + offsetX) / 8;
        indY = (y + h -1) / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;

        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
        //Se repite posicionando el supuesto movimiento 7 pixels a la derecha (Anchor izquierda | arriba)
        indX = (x  + offsetX + 8 -1) / 8;//
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;
        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
    }
    return 0;
}

UINT16 isCollisionUp(UINT16 x, UINT16 y, UINT16 w) {
    UINT16 indX;
    UINT16 indY;
    UINT16 indXY;
    UINT16 offsetX;
    UINT8 i;

    //Si el personaje mide mas de un tile en ancho, se va recorriendo toda su anchura (de 8 en 8) y comprobando si colisiona
    for(i = 0; i < w/8; i++){
        offsetX = i * 8;

        //Convierte la posicion del player en index x/y
        indX = (x + offsetX) / 8;
        indY = y / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;

        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
        //Se repite posicionando el supuesto movimiento 7 pixels a la derecha (Anchor izquierda | arriba)
        indX = (x + offsetX + 8 -1) / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;
        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
           return indXY;
        }
    }
    return 0;
}

UINT16 isCollisionRight(UINT16 x, UINT16 y, UINT16 w, UINT16 h) {
    UINT16 indX;
    UINT16 indY;
    UINT16 indXY;

    UINT16 offsetY;
    UINT8 i;

    //Si el personaje mide mas de un tile en alto, se va recorriendo toda su altura (de 8 en 8) y comprobando si colisiona
    for(i = 0; i < h/8; i++){
        offsetY = i * 8;
        //Convierte la posicion del player en index x/y
        indX = (x + w-1) / 8;
        indY = (y + offsetY) / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;

        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
        //Se repite posicionando el supuesto movimiento 7 pixels abajo (Anchor izquierda | arriba)
        indY = (y + offsetY + 8 -1) / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;
        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
    }
    return 0;
}

UINT16 isCollisionLeft(UINT16 x, UINT16 y, UINT16 h) {
    UINT16 indX;
    UINT16 indY;
    UINT16 indXY;

    UINT16 offsetY;
    UINT8 i;

    //Si el personaje mide mas de un tile en alto, se va recorriendo toda su altura (de 8 en 8) y comprobando si colisiona
    for(i = 0; i < h/8; i++){
        offsetY = i * 8;
        //Convierte la posicion del player en index x/y
        indX = x /8;
         indY = (y + offsetY) / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;

        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
        //Se repite posicionando el supuesto movimiento 7 pixels abajo (Anchor izquierda | arriba)
        indY = (y + offsetY + 8 -1) / 8;
        //Convierte los index x/y en xy
        indXY = (indY * TILES_WIDTH) + indX;
        //Recupero el tile
        if(TILE_LEVEL_MAP[indXY] != 0x00) {
            return indXY;
        }
    }
    return 0;
}

void main() {
    //Mierda temporal
    UINT16 tem = 0;
    UBYTE isInGround;
    UBYTE gameKeyPressed;
    UINT16 tileIndex;

    UINT16 tileX = 0;
    UINT16 tileY = 0;

    UINT16 points = 0;
    UBYTE gameFrame = 0;
    UBYTE keys = 0;

    char digitPoints[5];

    UBYTE bgPosX = 0;
    UBYTE bgPosY = 0;

    struct Player player;
    struct Camera camera;

    player.x = 0;
    player.y = (SCREEN_HEIGHT - PLAYER_HEIGHT - 8) INC_BITS;
    player.newX = player.x;
    player.newY = player.y;
    player.speed = 1 INC_BITS;
    player.frame = TILE_PLAYER_IDLE_F1;
    player.state = STATE_IDLE;

    digitPoints[0] = 0;
    digitPoints[1] = 0;
    digitPoints[2] = 0;
    digitPoints[3] = 0;
    digitPoints[4] = 0;



    DISPLAY_OFF;//Desactiva la pantalla
    disable_interrupts();
    HIDE_SPRITES;
    HIDE_BKG;
    HIDE_WIN;

    // los tiles y el mapa estan en el banco 2 de la ROM, el primero es de 16 kb solo y se debe reservar para el codigo
    //SWITCH_ROM_MBC1(2);

    //Background
    //Carga en la VRAM los tiles para los fondos
    //Pharams: posicion de memoria, cantidad de tiles, tiles
    //set_bkg_data(0, 131, TILES_BG);
    //Carga el mapa de tiles
    //Pharams: x, y, width, height, mapa
    //set_bkg_tiles(0, 0, 20, 18, LEVEL_MAP);

    //Tiles plataformas
    set_bkg_data(0, 3, TILE_LEVEL_DATA);
    //Pharams: x, y, width, height, mapa
    set_bkg_tiles(0, 0, TILES_WIDTH, TILES_HEIGHT, TILE_LEVEL_MAP);

    //Sprites
    //Carga en la VRAM los tiles para los sprites
    //Pharams: posicion de memoria, cantidad de tiles, tiles
    set_sprite_data(0, TOTAL_TILES, TILES_DATA);

    SPRITES_8x16;
    //Asigna a un sprite un tile
    //Pharams: numero del sprite (0-39), posicion del tile
    set_sprite_tile(SPRITE_DIGIT_1, TILE_0);
    set_sprite_tile(SPRITE_DIGIT_2, TILE_0);
    set_sprite_tile(SPRITE_DIGIT_3, TILE_0);
    set_sprite_tile(SPRITE_DIGIT_4, TILE_0);

    //Peko f1 //Mirar si se borra de aqui y se pone en la maquina de estados
    set_sprite_tile(SPRITE_PLAYER, TILE_PLAYER_IDLE_F1);

    SHOW_BKG;//Muestra el fondo
    SHOW_SPRITES;//Muestra los sprites
    DISPLAY_ON;
    enable_interrupts();

    while(1) {

        keys = joypad();//Lee el pad

        if(gameFrame == 60) {
            gameFrame = 0;
            points++;
        }

        //Set limits
        if(player.x < 2 INC_BITS){
            player.x = 1 INC_BITS;
        }
        else if((player.x DEC_BITS) +8 >= LEVEL_WIDTH){
            player.x = (LEVEL_WIDTH-8) INC_BITS;
        }

        //Player controls
        player.newX = player.x;
        player.newY = player.y;

        //Physics
        if(player.velocityAsc > 1 INC_BITS){
            player.velocityDesc = 0;
            player.newY -= player.velocityAsc;
            player.velocityAsc -= getGravitySpeed(3, 7);
        }else{
            player.velocityAsc = 0;
            player.velocityDesc += getGravitySpeed(3, 7);
            player.newY += player.velocityDesc;
            if(!isCollisonDown(player.x DEC_BITS, (player.y + (1 INC_BITS)) DEC_BITS, PLAYER_WIDTH, PLAYER_HEIGHT)){
                player.frame = TILE_PLAYER_JUMP_DOWN;
                player.state = STATE_JUMP;
            }
        }
        isInGround = isCollisonDown(player.x DEC_BITS, (player.y + (1 INC_BITS)) DEC_BITS, PLAYER_WIDTH, PLAYER_HEIGHT);

        if(keyPressSTART(keys) > 0){}
        if(keyPressSELECT(keys) > 0){}

        gameKeyPressed = FALSE;
        if(keyPressUP(keys) > 0) {
        }
        else if(keyPressDOWN(keys) > 0) {
        }
        if(keyPressLEFT(keys) > 0) {
            gameKeyPressed = TRUE;
            /* this will OR the flip x bit of sprite 0 to the value 1, making the sprite flip horizontally */
            set_sprite_prop(SPRITE_PLAYER, S_FLIPX);
            player.newX -=  player.speed;
            if(player.state == STATE_IDLE || (isInGround && player.state == STATE_JUMP)){
                player.frame = TILE_PLAYER_RUN_F1;
                player.state = STATE_RUN;
            }
        }
        else if(keyPressRIGHT(keys) > 0) {
            gameKeyPressed = TRUE;
            set_sprite_prop(SPRITE_PLAYER, 0);
            player.newX +=  player.speed;
            if(player.state == STATE_IDLE || (isInGround && player.state == STATE_JUMP)){
                player.frame = TILE_PLAYER_RUN_F1;
                player.state = STATE_RUN;
            }
        }
        if(keyPressA(keys) > 0) {
        }
        if(keyPressB(keys) > 0) {
            if(isInGround){
                gameKeyPressed = TRUE;
                player.velocityAsc = 2 INC_BITS;
                player.frame = TILE_PLAYER_JUMP_UP;
                player.state = STATE_JUMP;

            }
        }
        //Condiciones para volver a idle
        if(player.state != STATE_IDLE && isInGround && !gameKeyPressed){
                player.frame = TILE_PLAYER_IDLE_F1;
                player.state = STATE_IDLE;
        }

        tileIndex = isCollisonDown(player.x DEC_BITS, player.newY DEC_BITS, PLAYER_WIDTH, PLAYER_HEIGHT);
        if(tileIndex!=0){
            player.newY = (((tileIndex / TILES_WIDTH) * 8) - PLAYER_HEIGHT) INC_BITS;
            player.velocityDesc = 0;
        }
        tileIndex = isCollisionUp(player.x DEC_BITS, player.newY DEC_BITS, PLAYER_WIDTH);
        if(tileIndex!=0){
            player.newY = (((tileIndex / TILES_WIDTH) * 8) + 8) INC_BITS;
            player.velocityAsc = 0;
            player.velocityDesc = 0;
        }
        player.y = player.newY;

        tileIndex = isCollisionRight(player.newX DEC_BITS, player.y DEC_BITS, PLAYER_WIDTH, PLAYER_HEIGHT);
        if(tileIndex!=0){
            player.newX = (((tileIndex % TILES_WIDTH) * 8)-PLAYER_WIDTH) INC_BITS;
        }
        tileIndex = isCollisionLeft(player.newX DEC_BITS, player.y DEC_BITS, PLAYER_HEIGHT);
        if(tileIndex!=0){
            player.newX = (((tileIndex % TILES_WIDTH) * 8)+8) INC_BITS;
        }
        player.x = player.newX;

        camera.x = getCameraX(player.x DEC_BITS);

        //Maquina de estado del player

        switch(player.state){
            case STATE_RUN:
                player.frame = getFrameRun(gameFrame, player.frame);
                break;
            case STATE_JUMP:
                break;
            default:
                if(isInGround){
                    player.frame = getFrameIdle(gameFrame, player.frame);
                }
                break;

        }

        set_sprite_tile(SPRITE_PLAYER, player.frame);

        wait_vbl_done();//Sincroniza con el blanqueo vertical


        //Mueve el fondo
        move_bkg(camera.x, bgPosY);



        move_sprite(SPRITE_PLAYER, (player.x DEC_BITS) - camera.x+8, (player.y DEC_BITS) + PLAYER_HEIGHT);
        //move_sprite(SPRITE_PLAYER, player.x, player.y);




        drawPoints(gameFrame , 5, SCREEN_WIDTH - (8*4), 8);
        gameFrame++;
    }
}


